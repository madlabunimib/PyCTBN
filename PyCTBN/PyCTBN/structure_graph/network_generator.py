from .structure import Structure
from .network_graph import NetworkGraph
from .conditional_intensity_matrix import ConditionalIntensityMatrix
from .set_of_cims import SetOfCims
import numpy as np
import pandas as pd
import os
import json

class NetworkGenerator(object):
    """Provides the methods to generate a network graph and the CIMs related to it
    Items in _labels, _vals and _indxs are related, and therefore respect the same order
    
    :param _labels: List of variables labels that will be part of the network
    :type _labels: List
    :param _vals: List of cardinalities of the variables in network (defined in the same order as _labels)
    :type _vals: List
    :param _indxs: List of the nodes indexes
    :type _indxs: List
    :param _cims: It contains, for each variable label (the key), the SetOfCims object related to it
    :type _cims: Dict
    :param _graph: The NetworkGraph object representing the generated structure
    :type _graph: NetworkGraph
    """

    def __init__(self, labels, vals):
        self._labels = labels
        self._vals = vals
        self._indxs = np.array([i for i, l in enumerate(labels)])
        self._graph = None
        self._cims = None

    def generate_graph(self, density):
        """Generate the edges according to specified density, and then instantiate the NetworkGraph object
            to represent the network

        :param density: Probability of an edge between two nodes to exist
        :type density: float
        """

        edges = [(i, j) for i in self._labels for j in self._labels if np.random.binomial(1, density) == 1 and i != j]
        s = Structure(self._labels, self._indxs, self._vals, edges, len(self._labels))
        self._graph = NetworkGraph(s)
        self._graph.add_nodes(s.nodes_labels)
        self._graph.add_edges(s.edges)

    def generate_cims(self, min_val, max_val):
        """For each node, generate the corresponding SetOfCims. The objective is to group the CIMs 
            (actually generated by private method __generate_cim) according to parents possibles states of every node.
            This method must obviously be executed after the graph has been generated.

        :param min_val: Minimum value allowed for the coefficients in the CIMs
        :type min_val: float
        :param max_val: Maximum value allowed for the coefficients in the CIMs
        :type max_val: float
        """

        if self._graph is None:
            return

        self._cims = {}

        for i, l in enumerate(self._labels):
            p_info = self._graph.get_ordered_by_indx_set_of_parents(l)
            combs = self._graph.build_p_comb_structure_for_a_node(p_info[2])

            if len(p_info[0]) != 0:
                node_cims = []
                for comb in combs:
                    cim = self.__generate_cim(min_val, max_val, self._vals[i])
                    node_cims.append(ConditionalIntensityMatrix(cim = cim))
            else:
                node_cims = []
                cim = self.__generate_cim(min_val, max_val, self._vals[i])
                node_cims.append(ConditionalIntensityMatrix(cim = cim))
                
            self._cims[l] = SetOfCims(node_id = l, parents_states_number = p_info[2], node_states_number = self._vals[i], p_combs = combs, 
                cims = np.array(node_cims))

    def __generate_cim(self, min_val, max_val, shape):
        """Generate a valid CIM matrix, with coefficients in the range [min_val, max_val] and with dimension [shape, shape]

        :param min_val: Minimum value allowed for the coefficients in the CIMs
        :type min_val: float
        :param max_val: Maximum value allowed for the coefficients in the CIMs
        :type max_val: float
        :param shape: Number of elements in each dimension of the matrix (this actually is the cardinality of the node)
        :type shape: int
        """

        cim = np.empty(shape=(shape, shape))
        cim[:] = np.nan
        
        for i, c in enumerate(cim):
            diag = (max_val - min_val) * np.random.random_sample() + min_val
            row = np.random.rand(1, len(cim))[0]
            row /= (sum(row) - row[i])
            row *= diag
            row[i] = -1 * diag
            cim[i] = np.around(row, 4)

        return cim

    @property
    def graph(self) -> NetworkGraph:
        return self._graph

    @property
    def cims(self) -> dict:
        return self._cims   

    @property
    def dyn_str(self) -> list:
        return pd.DataFrame([[edge[0], edge[1]] for edge in self._graph.edges], columns = ["From", "To"])

    @property
    def variables(self) -> list:
        return pd.DataFrame([[l, self._vals[i]] for i, l in enumerate(self._labels)], columns = ["Name", "Value"])